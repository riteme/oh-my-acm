**无源汇可行流**

　　**建模方法：**

　　首先建立一个源ss和一个汇tt，一般称为附加源和附加汇。

　　对于图中的每条弧<u,v>，假设它容量上界为c，下界b，那么把这条边拆为三条只有上界的弧。

　　一条为<ss,v>，容量为b；

　　一条为<u,tt>，容量为b；

　　一条为<u,v>，容量为c−b。

　　其中前两条弧一般称为附加弧。

　　然后对这张图跑最大流，以ss为源，以tt为汇，如果所有的附加弧都满流，则原图有可行流。

　　这时，每条非附加弧的流量加上它的容量下界，就是原图中这条弧应该有的流量。

　　**理解方法：**

　　对于原图中的每条弧，我们把c−b

称为它的自由流量，意思就是只要它流满了下界，这些流多少都没问题。

　　既然如此，对于每条弧<u,v>，我们强制给v提供b单位的流量，并且强制从u那里拿走b单位的流量，这一步对应着两条附加弧。

　　如果这一系列强制操作能完成的话，也就是有一组可行流了。

　　**注意：这张图的最大流只是对应着原图的一组可行流，而不是原图的最大或最小流。**

------

**有源汇可行流**

　　**建模方法：**

　　建立弧<t,s>，容量下界为0，上界为∞。

　　然后对这个新图（实际上只是比原图多了一条边）按照无源汇可行流的方法建模，如果所有附加弧满流，则存在可行流。

　　求原图中每条边对应的实际流量的方法，同无源汇可行流，只是忽略掉弧<t,s>

就好。

　　而且这时候弧<t,s>的流量就是原图的总流量。

　　**理解方法：**

　　有源汇相比无源汇的不同就在于，源和汇是不满足流量平衡的，那么连接<t,s>

之后，源和汇也满足了流量平衡，就可以直接按照无源汇的方式建模。

　　**注意：这张图的最大流只是对应着原图的一组可行流，而不是原图的最大或最小流。**

------

**有源汇最大流**

　　**建模方法：**

　　首先按照有源汇可行流的方法建模，如果不存在可行流，更别提什么最大流了。

　　如果存在可行流，那么**在运行过有源汇可行流的图上（就是已经存在流量的那张图，流量不要清零）**，跑一遍从s到t的最大流（这里的s和t是原图的源和汇，不是附加源和附加汇），就是原图的最大流。

　　**理解方法：**

　　为什么要在那个已经有了流量的图上跑最大流？因为那张图保证了每条弧的容量下界，在这张图上跑最大流，实际上就是在容量下界全部满足的前提下尽量多得获得“自由流量”。

　　注意，在这张已经存在流量的图上，弧<t,s>也是存在流量的，千万不要忽略这条弧。因为它的相反弧<s,t>的流量为<t,s>的流量的相反数，且<s,t>的容量为0，所以这部分的流量也是会被算上的。

------

**有源汇最小流**

　　有源汇最小流的常见建模方法比较多，我就只说我常用的一种。

　　**建模方法：**

　　首先按照有源汇可行流的方法建模，但是**不要建立<t,s>这条弧**。

　　然后在这个图上，跑从附加源ss到附加汇tt的最大流。

　　这时候再添加弧<t,s>，下界为0，上界为∞。

　　在现在的这张图上，从ss到tt的最大流，就是原图的最小流。

　　**理解方法：**

　　我们前面提到过，有源汇可行流的流量只是对应一组可行流，并不是最大或者最小流。

　　并且在跑完有源汇可行流之后，弧<t,s>的流量就是原图的流量。

　　从这个角度入手，我们想让弧<t,s>的流量尽量小，就要尽量多的消耗掉那些“本来不需要经过<t,s>”的流量。

　　于是我们在添加<t,s>之前，跑一遍从ss到tt的最大流，就能尽量多的消耗那些流量啦QwQ。

https://www.cnblogs.com/mlystdcall/p/6734852.html







如果想用这个来求最长反链的话，那么构造出上下界费用流的图之后，初始的可行流可以直接构造：因为之前是每个点拆点的，那么就每个点用一条链覆盖住，然后直接跑退流过程就好。复杂度依然是玄学，但好像挺快(loj6197)

其他可以直接构造的也都是只用跑第二次dinic





带下界费用流直接对这张图跑费用流



带负环的费用流：对于负费用边$x\rightarrow y$可以先强制满流，然后加入$y\rightarrow x$的边用于退流。满流的方式就是加入上下界的边(x,y,1,1,0)，用上下界的方式建图。

```c++
void addt ( int u , int v , int f , int c ) {
	if ( c >= 0 ) addtt ( u , v , f , c );
	else {
		addtt ( sss , v , f , 0 );
		addtt ( v , u , f , -c );
		addtt ( u , ttt , f , 0 );
		base2 += f * c;
	}
}
```

然后跑的时候先跑一个dinic(ss,tt)的最小费用最大流，再跑一个dinic(s,t)的最小费用最大流。得到的结果就是s,t的最小费用最大流。

如果本来就是上下界费用流，就需要建立建立完超级源汇之后第二次建立超级源汇，在(sss,ttt)中跑一次，然后在(ss,tt)中跑一次。

https://www.luogu.com.cn/problem/solution/P7173



加速某种二分图最大匹配的方法：如果一边的所有点的度数都是二，那么可以把左边的点看成右边对应两个点连出来的边，然后一个匹配就相当于右侧图的一个生成基环森林，如果要是完美匹配就要求所有联通块都要有一个环。用Kruskal找个生成森林就可以了，还可以求带权版本的。输出方案可以在并查集连环的时候，把这个边对应一个点，然后这个点当成根。最后把剩下的树以这个点为根dfs一边。cfgym101741E



二分图dinic建图的时候可以考虑交换一下流的方向，说不定会快很多。

用vector<node\*>存边会快一些。