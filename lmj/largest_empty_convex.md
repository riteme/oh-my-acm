算法一

先枚举每个点作为凸包的最下面的点O，不考虑它下方的点，其余点以O为原点极角排序。

再枚举凸包最后一个点i与O相连,设dp[i][j](i>j)表示组成凸包的最后一个三角形是Oij的最大凸包面积，那么容易得到dp方程：dp[i][j]=max(SΔOij+dp[j][k]),(ΔOij内无点且边Oi上无点且k在ij→右侧保证凸性)；
注意到如果边Oi上有点，它就只能作为凸包的边界，所以不能更新dp[i][j]，但还是要用max(SΔOij+dp[j][k])更新最终答案，否则用dp[i][j]更新答案。但这样单次dp的复杂度是O(n3)的，考虑优化这个过程，所以有了算法二。
算法二

还是枚举凸包最后一个点i，dp意义也相同。可以发现，合法的j可用以下方法得到：1.令j1=i−1,可以保证ΔOij合法；如果j1在Oi上，那么从大到小枚举第一个不在Oi上的点作为j1，但这样Oi上就有点了，处理方法同上。
2.令j2为最大的在ij1→右侧的点，j3为最大的在ij2→右侧的点……可以证明这样可以找出所有合法的j。
3.注意到找出的j序列是满足凸性的，且dp[i][jn]的第一个可以转移来的点就是jn+1,所以可以用g[i][j]表示max(dp[i][k],1≤k≤j)，那么就有dp[i][jn]=SΔOij+g[i][jn+1]注：1~j中不合法的点dp值为0，不影响g的更新，所以g数组一定满足凸性；但如果Oi上有点还是不更新dp和g
，但还是要更新最终答案。
这样枚举原点是O(n)的，枚举凸包最后一点i是O(n)的，枚举合法的j是O(n)的，转移是O(1)的，更新g数组是O(n)的，所以总复杂度是O(n3)的。

代码里求的是面积

https://blog.csdn.net/cdsszjj/article/details/79366813